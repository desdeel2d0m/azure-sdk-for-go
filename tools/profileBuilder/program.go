package main

// Copyright 2017 Microsoft Corporation
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

import (
	"errors"
	"flag"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/marstr/collection"
	goalias "github.com/marstr/goalias/model"
	"github.com/marstr/randname"
)

var (
	profileName     string
	outputLocation  string
	inputRoot       string
	inputList       io.Reader
	packageStrategy collection.Enumerable
	outputLog       *log.Logger
	errLog          *log.Logger
)

// WellKnownStrategy is an Enumerable which lists all known strategies for choosing packages for a profile.
type WellKnownStrategy string

// This block declares the definitive list of WellKnownStrategies
const (
	WellKnownStrategyList   WellKnownStrategy = "list"
	WellKnownStrategyLatest WellKnownStrategy = "latest"
)

// If not the empty string, this string should be stamped into files generated by the profileBuilder.
// Note: This variable should be set by passing the argument "-X main.version=`{your value}`"" to the Go linker.
var version string

func main() {
	var packages collection.Enumerator

	done := make(chan struct{})

	type alias struct {
		*goalias.AliasPackage
		TargetPath string
	}

	// Convert paths that were found to Absolute paths if they were not already.
	packages = packageStrategy.Enumerate(done).Select(func(x interface{}) interface{} {
		if cast, ok := x.(string); ok {
			abs, err := filepath.Abs(cast)
			if err != nil {
				return nil
			}
			return abs
		}
		return nil
	}).SelectMany(func(x interface{}) collection.Enumerator {
		results := make(chan interface{})

		go func() {
			defer close(results)

			cast, ok := x.(string)
			if !ok {
				return
			}
			files := token.NewFileSet()
			parsed, err := parser.ParseDir(files, cast, nil, parser.ParseComments)
			if err != nil {
				return
			}

			for _, entry := range parsed {
				outputLog.Printf("Package `%s` found in at: %s", entry.Name, cast)
				results <- entry
			}
		}()

		return results
	}).ParallelSelect(func(x interface{}) interface{} {
		cast, ok := x.(*ast.Package)
		if !ok {
			return nil
		}

		var bundle alias
		subject, err := goalias.NewAliasPackage(cast)
		if err != nil {
			return nil
		}

		bundle.AliasPackage = subject
		for filename := range cast.Files {
			bundle.TargetPath = filepath.Dir(filename)
			bundle.TargetPath, err = getAliasPath(bundle.TargetPath, profileName)
			if err != nil {
				errLog.Print(err)
				return nil
			}
			break
		}

		outputLog.Printf("Alias created for package: %s", cast.Name)
		return &bundle
	}).Where(func(x interface{}) bool {
		return x != nil
	}).ParallelSelect(func(x interface{}) interface{} {
		cast, ok := x.(*alias)
		if !ok {
			return false
		}

		files := token.NewFileSet()

		outputPath := filepath.Join(outputLocation, cast.TargetPath, "models.go")
		outputPath = strings.Replace(outputPath, `\`, `/`, -1)
		outputLog.Print("Making directory: ", path.Dir(outputPath))
		err := os.MkdirAll(path.Dir(outputPath), os.ModePerm|os.ModeDir)
		if err != nil {
			errLog.Print("error creating directory:", err)
			return false
		}

		outputFile, err := os.Create(outputPath)
		if err != nil {
			errLog.Print("error creating file: ", err)
			return false
		}

		outputLog.Printf("Writing File: %s", outputPath)
		printer.Fprint(outputFile, files, cast.ModelFile())

		return true
	})

	generated := 0

	// Write each aliased package that was found
	for entry := range packages {
		if entry.(bool) {
			generated++
		}
	}
	close(done)

	outputLog.Print(generated, " packages generated.")

}

func init() {
	const defaultName = "{randomly generated}"

	var selectedStrategy string
	var inputListLocation string
	var useVerbose bool

	flag.StringVar(&profileName, "name", defaultName, "The name that should be given to the generated profile.")
	flag.StringVar(&outputLocation, "o", defaultOutputLocation(), "The output location for the package generated as a profile.")
	flag.StringVar(&inputRoot, "root", defaultInputRoot(), "The location of the Azure SDK for Go's service packages.")
	flag.StringVar(&inputListLocation, "l", "", "If the `list` strategy is chosen, -l is the location of the file to read for said list. If not present, stdin is used.")
	flag.StringVar(&selectedStrategy, "s", string(WellKnownStrategyLatest), "The strategy to employ for finding packages to put in a profile.")
	flag.BoolVar(&useVerbose, "v", false, "Write status to stderr as the program progresses")
	flag.Parse()

	// Setup Verbose Status Log and Error Log
	var logWriter io.Writer
	if useVerbose {
		logWriter = os.Stderr
	} else {
		logWriter = ioutil.Discard
	}
	outputLog = log.New(logWriter, "[STATUS] ", 0)
	outputLog.Print("Status Logging Enabled")

	errLog = log.New(logWriter, "[ERROR] ", 0)

	if version != "" {
		outputLog.Print("profileBuilder Version: ", version)
	}

	// Sort out the Profile Name to be used.
	if profileName == defaultName {
		profileName = randname.AdjNoun{}.Generate()
		outputLog.Print("Profile Name Set to: ", profileName)
	}

	//
	inputList = os.Stdin
	if inputListLocation == "" {
		outputLog.Print("Reading input from standard input")
	} else {
		var err error
		outputLog.Print("Reading input from: ", inputListLocation)
		inputList, err = os.Open(inputListLocation)
		if err != nil {
			errLog.Print(err)
			os.Exit(1)
		}
	}

	wellKnownStrategies := map[WellKnownStrategy]collection.Enumerable{
		WellKnownStrategyList:   ListStrategy{Reader: inputList},
		WellKnownStrategyLatest: LatestStrategy{Root: inputRoot},
	}

	if s, ok := wellKnownStrategies[WellKnownStrategy(selectedStrategy)]; ok {
		packageStrategy = s
		outputLog.Printf("Using Well Known Strategy: %s", selectedStrategy)
	} else {
		errLog.Printf("Unknown strategy for identifying packages: %s\n", selectedStrategy)
		os.Exit(1)
	}
}

// AzureSDKforGoLocation returns the default location for the Azure-SDK-for-Go to reside.
func AzureSDKforGoLocation() string {
	return path.Join(
		os.Getenv("GOPATH"),
		"src",
		"github.com",
		"Azure",
		"azure-sdk-for-go",
	)
}

func defaultOutputLocation() string {
	return path.Join(AzureSDKforGoLocation(), "profile")
}

func defaultInputRoot() string {
	return path.Join(AzureSDKforGoLocation(), "service")
}

// getAliasPath takes an existing API Version path and a package name, and converts the path
// to a path which uses the new profile layout.
func getAliasPath(subject, profile string) (transformed string, err error) {
	subject = strings.TrimSuffix(subject, "/")
	subject = trimGoPath(subject)

	matches := packageName.FindAllStringSubmatch(subject, -1)
	if matches == nil {
		err = errors.New("path does not resemble a known package path")
		return
	}

	output := []string{
		profile,
		matches[0][1],
	}

	if matches[0][2] == "management/" {
		output = append(output, "management")
	}

	output = append(output, matches[0][3])

	transformed = strings.Join(output, "/")
	return
}

// trimGoPath removes the prefix defined in the environment variabe GOPATH if it is present in the string provided.
var trimGoPath = func() func(string) string {
	splitGo := strings.Split(os.Getenv("GOPATH"), string(os.PathSeparator))
	splitGo = append(splitGo, "src")

	return func(subject string) string {
		splitPath := strings.Split(subject, string(os.PathSeparator))
		for i, dir := range splitGo {
			if splitPath[i] != dir {
				return subject
			}
		}
		packageIdentifier := splitPath[len(splitGo):]
		return path.Join(packageIdentifier...)
	}
}()
